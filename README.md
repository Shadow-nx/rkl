# rkl

task 2:
 пример список: 1 -> 2 -> 3 -> 4 -> 5
 разворачиваем указатели next в орабтном направление  1 <- 2 <- 3 <- 4 <- 5 и перебрасываем first на последний тоесть на 5-ку
 
 
 task 3:
  вводим с клавиатуры номер элемента с конца,затем считаем общее колличество элементов в списке отнимаем от общегои колличество позицию элемента с конца которую нужно найти,мы получаем позицию элемента сначала ,создаем цикл от 0 до позиции ,дойдя до нее выводим значение


 task 4: принцип алгоритма в том что мы имеем 2 указателя, они оба бегают по списку,один из них в два раза медленее за счет логической переменной которая каждый цикл меняется на противоположную и в случае когда равен true указатель смещается на 1 второй(быстрый) смещается каждую итерацию цикла, если быстрый указатель найдет nullptr т о зацикливания нет, если догонит медленный,то зацикливание есть и цикл прерывается
